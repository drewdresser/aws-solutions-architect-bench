{"id": "arch_001", "type": "diagram_interpretation", "subtype": "service_identification", "difficulty": "beginner", "diagram_path": "diagrams/beginner/three_tier_web_app.png", "input": "Identify all AWS services shown in this three-tier web application architecture and explain their roles in the system.", "target": "Amazon EC2 (Web and application servers hosting the application logic), Amazon RDS (Managed relational database service for data persistence), Elastic Load Balancer (Distributes incoming traffic across multiple EC2 instances), Amazon VPC (Virtual private cloud providing network isolation), Auto Scaling Group (Automatically adjusts the number of EC2 instances based on demand)", "expected_services": [{"service": "Amazon EC2", "role": "Web and application servers hosting the application logic"}, {"service": "Amazon RDS", "role": "Managed relational database service for data persistence"}, {"service": "Elastic Load Balancer", "role": "Distributes incoming traffic across multiple EC2 instances"}, {"service": "Amazon VPC", "role": "Virtual private cloud providing network isolation"}, {"service": "Auto Scaling Group", "role": "Automatically adjusts the number of EC2 instances based on demand"}], "scoring_criteria": {"service_accuracy": 0.4, "role_explanation": 0.4, "completeness": 0.2}}
{"id": "arch_002", "type": "diagram_interpretation", "subtype": "data_flow_analysis", "difficulty": "beginner", "diagram_path": "diagrams/beginner/three_tier_basic.png", "input": "Trace the data flow from a user request to the database and back in this three-tier architecture. Explain each step and the components involved.", "target": "1. User sends HTTP request to Load Balancer, 2. Load Balancer forwards request to available EC2 instance in Web Tier, 3. Web Tier processes request and forwards to Application Tier, 4. Application Tier processes business logic and queries Database Tier, 5. Database returns data to Application Tier, 6. Application Tier processes response and sends to Web Tier, 7. Web Tier formats response and sends back through Load Balancer to user", "expected_flow": ["User sends HTTP request to Load Balancer", "Load Balancer forwards request to available EC2 instance in Web Tier", "Web Tier processes request and forwards to Application Tier", "Application Tier processes business logic and queries Database Tier", "Database returns data to Application Tier", "Application Tier processes response and sends to Web Tier", "Web Tier formats response and sends back through Load Balancer to user"], "scoring_criteria": {"flow_accuracy": 0.5, "component_understanding": 0.3, "completeness": 0.2}}
{"id": "arch_003", "type": "diagram_interpretation", "subtype": "security_assessment", "difficulty": "intermediate", "diagram_path": "diagrams/intermediate/web_application_ref.png", "input": "Analyze the security components and potential vulnerabilities in this web application reference architecture. Identify security best practices implemented and suggest improvements.", "target": "Security components: VPC with public and private subnets, Security Groups acting as virtual firewalls, NAT Gateway for outbound internet access from private subnets, Internet Gateway for public subnet access, Database in private subnet. Improvements: Add AWS WAF for application layer protection, Implement AWS Shield for DDoS protection, Use AWS Certificate Manager for SSL/TLS certificates, Add CloudTrail for audit logging, Implement AWS Config for compliance monitoring", "expected_security_components": ["VPC with public and private subnets", "Security Groups acting as virtual firewalls", "NAT Gateway for outbound internet access from private subnets", "Internet Gateway for public subnet access", "Database in private subnet"], "potential_improvements": ["Add AWS WAF for application layer protection", "Implement AWS Shield for DDoS protection", "Use AWS Certificate Manager for SSL/TLS certificates", "Add CloudTrail for audit logging", "Implement AWS Config for compliance monitoring"], "scoring_criteria": {"security_identification": 0.3, "vulnerability_assessment": 0.3, "improvement_suggestions": 0.4}}
{"id": "arch_004", "type": "diagram_interpretation", "subtype": "scalability_analysis", "difficulty": "intermediate", "diagram_path": "diagrams/intermediate/serverless_patterns.png", "input": "Evaluate the scalability characteristics of this serverless architecture pattern. Identify scaling mechanisms and potential bottlenecks.", "target": "Scaling mechanisms: AWS Lambda automatic scaling, API Gateway automatic scaling, DynamoDB on-demand scaling, S3 virtually unlimited storage. Bottlenecks: Lambda concurrent execution limits, API Gateway throttling limits, DynamoDB read/write capacity if not properly configured, External service dependencies. Benefits: Pay-per-use pricing model, No server management overhead, Automatic scaling to zero when not in use, Built-in high availability", "expected_scaling_mechanisms": ["AWS Lambda automatic scaling", "API Gateway automatic scaling", "DynamoDB on-demand scaling", "S3 virtually unlimited storage"], "potential_bottlenecks": ["Lambda concurrent execution limits", "API Gateway throttling limits", "DynamoDB read/write capacity if not properly configured", "External service dependencies"], "scaling_benefits": ["Pay-per-use pricing model", "No server management overhead", "Automatic scaling to zero when not in use", "Built-in high availability"], "scoring_criteria": {"scaling_mechanism_identification": 0.4, "bottleneck_analysis": 0.3, "scalability_understanding": 0.3}}
{"id": "arch_005", "type": "diagram_interpretation", "subtype": "cost_optimization", "difficulty": "advanced", "diagram_path": "diagrams/advanced/reactive_microservices.jpg", "input": "Analyze this reactive microservices architecture for cost optimization opportunities. Consider compute, storage, and data transfer costs.", "target": "Cost optimization opportunities: Use Spot Instances for non-critical workloads, Implement Auto Scaling to match capacity with demand, Use Reserved Instances for predictable workloads, Optimize data transfer by keeping services in same AZ, Use CloudWatch to identify underutilized resources, Implement caching with ElastiCache to reduce database load. Cost factors: EC2 instance types and sizes, Data transfer between services, Database read/write operations, Load balancer usage, Storage costs for logs and data", "cost_optimization_opportunities": ["Use Spot Instances for non-critical workloads", "Implement Auto Scaling to match capacity with demand", "Use Reserved Instances for predictable workloads", "Optimize data transfer by keeping services in same AZ", "Use CloudWatch to identify underutilized resources", "Implement caching with ElastiCache to reduce database load"], "cost_factors": ["EC2 instance types and sizes", "Data transfer between services", "Database read/write operations", "Load balancer usage", "Storage costs for logs and data"], "scoring_criteria": {"cost_opportunity_identification": 0.4, "cost_factor_understanding": 0.3, "optimization_feasibility": 0.3}}
{"id": "arch_006", "type": "diagram_creation", "subtype": "requirements_to_architecture", "difficulty": "intermediate", "output_format": "mermaid", "input": "Design a highly available web application architecture that can handle 10,000 concurrent users, requires 99.9% uptime, needs to store user data securely, and should be cost-effective. The application will serve both web and mobile clients. Output your architecture as a Mermaid flowchart diagram using ```mermaid code blocks.", "target": "Architecture components: Multi-AZ deployment, Application Load Balancer, Auto Scaling Groups, RDS with Multi-AZ, CloudFront CDN, S3 for static assets, ElastiCache for caching. Design principles: High availability through redundancy across multiple AZs, Scalability through auto scaling mechanisms, Security through VPC isolation and security groups, Cost optimization through right-sizing and efficient resource usage", "requirements": "Design a highly available web application architecture that can handle 10,000 concurrent users, requires 99.9% uptime, needs to store user data securely, and should be cost-effective. The application will serve both web and mobile clients.", "expected_components": ["ALB", "EC2", "RDS", "CloudFront", "S3", "ElastiCache", "Auto Scaling"], "architectural_principles": ["High availability through redundancy", "Scalability through auto scaling", "Security through VPC and security groups", "Cost optimization through right-sizing"], "scoring_criteria": {"requirement_adherence": 0.3, "component_selection": 0.3, "architectural_soundness": 0.4}}
{"id": "arch_007", "type": "diagram_creation", "subtype": "pattern_implementation", "difficulty": "advanced", "output_format": "plantuml", "input": "Implement an event-driven microservices architecture pattern with the following constraints: Must use serverless components where possible, requires asynchronous communication, should support event replay, and must handle failures gracefully. Output your architecture as a PlantUML component diagram using ```plantuml code blocks.", "target": "Pattern elements: AWS Lambda for microservices, Amazon EventBridge for event routing, Amazon SQS for message queuing, Amazon DynamoDB for event store, AWS Step Functions for workflow orchestration. Benefits: Loose coupling between services, Scalability and resilience, Event sourcing capabilities, Fault tolerance through retry mechanisms and dead letter queues", "pattern": "Event-driven microservices architecture", "constraints": ["Must use serverless components where possible", "Requires asynchronous communication", "Should support event replay", "Must handle failures gracefully"], "expected_components": ["Lambda", "EventBridge", "SQS", "DynamoDB", "Step Functions"], "expected_pattern_elements": ["AWS Lambda for microservices", "Amazon EventBridge for event routing", "Amazon SQS for message queuing", "Amazon DynamoDB for event store", "AWS Step Functions for workflow orchestration"], "pattern_benefits": ["Loose coupling between services", "Scalability and resilience", "Event sourcing capabilities", "Fault tolerance"], "scoring_criteria": {"pattern_compliance": 0.4, "serverless_usage": 0.3, "fault_tolerance": 0.3}}
{"id": "arch_008", "type": "diagram_creation", "subtype": "problem_solving", "difficulty": "advanced", "output_format": "json", "input": "A legacy monolithic application needs to be migrated to AWS with minimal downtime. The application has a large database, file storage, and serves 50,000 daily active users. Design a migration strategy and target architecture with the following constraints: Maximum 4 hours downtime allowed, must maintain data consistency, should improve performance, and budget constraints require cost optimization. Output your architecture as a JSON object with 'architecture' containing 'components' (array with id, type, aws_service) and 'relationships' (array with from, to, type) using ```json code blocks.", "target": "Solution elements: Strangler Fig pattern for gradual migration, Database replication for minimal downtime, CloudFront for improved performance, S3 for file storage migration, Application Load Balancer for traffic routing. Migration phases: Assessment and planning, Database migration setup, Application component migration, Traffic cutover, Legacy system decommission", "problem": "A legacy monolithic application needs to be migrated to AWS with minimal downtime. The application has a large database, file storage, and serves 50,000 daily active users. Design a migration strategy and target architecture.", "constraints": ["Maximum 4 hours downtime allowed", "Must maintain data consistency", "Should improve performance", "Budget constraints require cost optimization"], "expected_components": ["ALB", "CloudFront", "S3", "DMS", "RDS"], "expected_solution_elements": ["Strangler Fig pattern for gradual migration", "Database replication for minimal downtime", "CloudFront for improved performance", "S3 for file storage migration", "Application Load Balancer for traffic routing"], "migration_phases": ["Assessment and planning", "Database migration setup", "Application component migration", "Traffic cutover", "Legacy system decommission"], "scoring_criteria": {"migration_strategy": 0.4, "downtime_minimization": 0.3, "risk_mitigation": 0.3}}
{"id": "arch_009", "type": "diagram_creation", "subtype": "requirements_to_architecture", "difficulty": "beginner", "output_format": "mermaid", "input": "Design a simple static website hosting architecture on AWS. Requirements: Host a React single-page application, support custom domain with HTTPS, handle global users with low latency, and keep costs minimal for low traffic. Output your architecture as a Mermaid flowchart diagram using ```mermaid code blocks.", "target": "Architecture components: Amazon S3 for static hosting, CloudFront for CDN and HTTPS, Route 53 for DNS, ACM for SSL certificate. Design principles: Serverless and cost-effective, Global edge distribution, Secure by default with HTTPS", "requirements": "Host a React SPA with custom domain, HTTPS, global low latency, minimal cost", "expected_components": ["S3", "CloudFront", "Route 53", "ACM"], "architectural_principles": ["Serverless and cost-effective", "Global edge distribution", "Secure by default"], "scoring_criteria": {"requirement_adherence": 0.3, "component_selection": 0.4, "architectural_soundness": 0.3}}
